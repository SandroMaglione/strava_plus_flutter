// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'dio_error_options.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$DioErrorOptionsTearOff {
  const _$DioErrorOptionsTearOff();

// ignore: unused_element
  ResponseDioErrorOptions response() {
    return const ResponseDioErrorOptions();
  }

// ignore: unused_element
  ConnectionTimeoutDioErrorOptions connection_timeout() {
    return const ConnectionTimeoutDioErrorOptions();
  }

// ignore: unused_element
  SendTimeoutDioErrorOptions send_timeout() {
    return const SendTimeoutDioErrorOptions();
  }

// ignore: unused_element
  ReceiveTimeoutDioErrorOptions receive_timeout() {
    return const ReceiveTimeoutDioErrorOptions();
  }

// ignore: unused_element
  CancelDioErrorOptions cancel() {
    return const CancelDioErrorOptions();
  }

// ignore: unused_element
  DefaultErrorDioErrorOptions default_error() {
    return const DefaultErrorDioErrorOptions();
  }

// ignore: unused_element
  UnknownDioErrorOptions unknown() {
    return const UnknownDioErrorOptions();
  }
}

/// @nodoc
// ignore: unused_element
const $DioErrorOptions = _$DioErrorOptionsTearOff();

/// @nodoc
mixin _$DioErrorOptions {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $DioErrorOptionsCopyWith<$Res> {
  factory $DioErrorOptionsCopyWith(
          DioErrorOptions value, $Res Function(DioErrorOptions) then) =
      _$DioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$DioErrorOptionsCopyWithImpl<$Res>
    implements $DioErrorOptionsCopyWith<$Res> {
  _$DioErrorOptionsCopyWithImpl(this._value, this._then);

  final DioErrorOptions _value;
  // ignore: unused_field
  final $Res Function(DioErrorOptions) _then;
}

/// @nodoc
abstract class $ResponseDioErrorOptionsCopyWith<$Res> {
  factory $ResponseDioErrorOptionsCopyWith(ResponseDioErrorOptions value,
          $Res Function(ResponseDioErrorOptions) then) =
      _$ResponseDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$ResponseDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $ResponseDioErrorOptionsCopyWith<$Res> {
  _$ResponseDioErrorOptionsCopyWithImpl(ResponseDioErrorOptions _value,
      $Res Function(ResponseDioErrorOptions) _then)
      : super(_value, (v) => _then(v as ResponseDioErrorOptions));

  @override
  ResponseDioErrorOptions get _value => super._value as ResponseDioErrorOptions;
}

/// @nodoc
class _$ResponseDioErrorOptions
    with DiagnosticableTreeMixin
    implements ResponseDioErrorOptions {
  const _$ResponseDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.response()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'DioErrorOptions.response'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ResponseDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return response();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class ResponseDioErrorOptions implements DioErrorOptions {
  const factory ResponseDioErrorOptions() = _$ResponseDioErrorOptions;
}

/// @nodoc
abstract class $ConnectionTimeoutDioErrorOptionsCopyWith<$Res> {
  factory $ConnectionTimeoutDioErrorOptionsCopyWith(
          ConnectionTimeoutDioErrorOptions value,
          $Res Function(ConnectionTimeoutDioErrorOptions) then) =
      _$ConnectionTimeoutDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConnectionTimeoutDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $ConnectionTimeoutDioErrorOptionsCopyWith<$Res> {
  _$ConnectionTimeoutDioErrorOptionsCopyWithImpl(
      ConnectionTimeoutDioErrorOptions _value,
      $Res Function(ConnectionTimeoutDioErrorOptions) _then)
      : super(_value, (v) => _then(v as ConnectionTimeoutDioErrorOptions));

  @override
  ConnectionTimeoutDioErrorOptions get _value =>
      super._value as ConnectionTimeoutDioErrorOptions;
}

/// @nodoc
class _$ConnectionTimeoutDioErrorOptions
    with DiagnosticableTreeMixin
    implements ConnectionTimeoutDioErrorOptions {
  const _$ConnectionTimeoutDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.connection_timeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DioErrorOptions.connection_timeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ConnectionTimeoutDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return connection_timeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (connection_timeout != null) {
      return connection_timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return connection_timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (connection_timeout != null) {
      return connection_timeout(this);
    }
    return orElse();
  }
}

abstract class ConnectionTimeoutDioErrorOptions implements DioErrorOptions {
  const factory ConnectionTimeoutDioErrorOptions() =
      _$ConnectionTimeoutDioErrorOptions;
}

/// @nodoc
abstract class $SendTimeoutDioErrorOptionsCopyWith<$Res> {
  factory $SendTimeoutDioErrorOptionsCopyWith(SendTimeoutDioErrorOptions value,
          $Res Function(SendTimeoutDioErrorOptions) then) =
      _$SendTimeoutDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$SendTimeoutDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $SendTimeoutDioErrorOptionsCopyWith<$Res> {
  _$SendTimeoutDioErrorOptionsCopyWithImpl(SendTimeoutDioErrorOptions _value,
      $Res Function(SendTimeoutDioErrorOptions) _then)
      : super(_value, (v) => _then(v as SendTimeoutDioErrorOptions));

  @override
  SendTimeoutDioErrorOptions get _value =>
      super._value as SendTimeoutDioErrorOptions;
}

/// @nodoc
class _$SendTimeoutDioErrorOptions
    with DiagnosticableTreeMixin
    implements SendTimeoutDioErrorOptions {
  const _$SendTimeoutDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.send_timeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DioErrorOptions.send_timeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SendTimeoutDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return send_timeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (send_timeout != null) {
      return send_timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return send_timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (send_timeout != null) {
      return send_timeout(this);
    }
    return orElse();
  }
}

abstract class SendTimeoutDioErrorOptions implements DioErrorOptions {
  const factory SendTimeoutDioErrorOptions() = _$SendTimeoutDioErrorOptions;
}

/// @nodoc
abstract class $ReceiveTimeoutDioErrorOptionsCopyWith<$Res> {
  factory $ReceiveTimeoutDioErrorOptionsCopyWith(
          ReceiveTimeoutDioErrorOptions value,
          $Res Function(ReceiveTimeoutDioErrorOptions) then) =
      _$ReceiveTimeoutDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$ReceiveTimeoutDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $ReceiveTimeoutDioErrorOptionsCopyWith<$Res> {
  _$ReceiveTimeoutDioErrorOptionsCopyWithImpl(
      ReceiveTimeoutDioErrorOptions _value,
      $Res Function(ReceiveTimeoutDioErrorOptions) _then)
      : super(_value, (v) => _then(v as ReceiveTimeoutDioErrorOptions));

  @override
  ReceiveTimeoutDioErrorOptions get _value =>
      super._value as ReceiveTimeoutDioErrorOptions;
}

/// @nodoc
class _$ReceiveTimeoutDioErrorOptions
    with DiagnosticableTreeMixin
    implements ReceiveTimeoutDioErrorOptions {
  const _$ReceiveTimeoutDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.receive_timeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DioErrorOptions.receive_timeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ReceiveTimeoutDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return receive_timeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (receive_timeout != null) {
      return receive_timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return receive_timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (receive_timeout != null) {
      return receive_timeout(this);
    }
    return orElse();
  }
}

abstract class ReceiveTimeoutDioErrorOptions implements DioErrorOptions {
  const factory ReceiveTimeoutDioErrorOptions() =
      _$ReceiveTimeoutDioErrorOptions;
}

/// @nodoc
abstract class $CancelDioErrorOptionsCopyWith<$Res> {
  factory $CancelDioErrorOptionsCopyWith(CancelDioErrorOptions value,
          $Res Function(CancelDioErrorOptions) then) =
      _$CancelDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $CancelDioErrorOptionsCopyWith<$Res> {
  _$CancelDioErrorOptionsCopyWithImpl(
      CancelDioErrorOptions _value, $Res Function(CancelDioErrorOptions) _then)
      : super(_value, (v) => _then(v as CancelDioErrorOptions));

  @override
  CancelDioErrorOptions get _value => super._value as CancelDioErrorOptions;
}

/// @nodoc
class _$CancelDioErrorOptions
    with DiagnosticableTreeMixin
    implements CancelDioErrorOptions {
  const _$CancelDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.cancel()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'DioErrorOptions.cancel'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CancelDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class CancelDioErrorOptions implements DioErrorOptions {
  const factory CancelDioErrorOptions() = _$CancelDioErrorOptions;
}

/// @nodoc
abstract class $DefaultErrorDioErrorOptionsCopyWith<$Res> {
  factory $DefaultErrorDioErrorOptionsCopyWith(
          DefaultErrorDioErrorOptions value,
          $Res Function(DefaultErrorDioErrorOptions) then) =
      _$DefaultErrorDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$DefaultErrorDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $DefaultErrorDioErrorOptionsCopyWith<$Res> {
  _$DefaultErrorDioErrorOptionsCopyWithImpl(DefaultErrorDioErrorOptions _value,
      $Res Function(DefaultErrorDioErrorOptions) _then)
      : super(_value, (v) => _then(v as DefaultErrorDioErrorOptions));

  @override
  DefaultErrorDioErrorOptions get _value =>
      super._value as DefaultErrorDioErrorOptions;
}

/// @nodoc
class _$DefaultErrorDioErrorOptions
    with DiagnosticableTreeMixin
    implements DefaultErrorDioErrorOptions {
  const _$DefaultErrorDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.default_error()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DioErrorOptions.default_error'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DefaultErrorDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return default_error();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (default_error != null) {
      return default_error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return default_error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (default_error != null) {
      return default_error(this);
    }
    return orElse();
  }
}

abstract class DefaultErrorDioErrorOptions implements DioErrorOptions {
  const factory DefaultErrorDioErrorOptions() = _$DefaultErrorDioErrorOptions;
}

/// @nodoc
abstract class $UnknownDioErrorOptionsCopyWith<$Res> {
  factory $UnknownDioErrorOptionsCopyWith(UnknownDioErrorOptions value,
          $Res Function(UnknownDioErrorOptions) then) =
      _$UnknownDioErrorOptionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnknownDioErrorOptionsCopyWithImpl<$Res>
    extends _$DioErrorOptionsCopyWithImpl<$Res>
    implements $UnknownDioErrorOptionsCopyWith<$Res> {
  _$UnknownDioErrorOptionsCopyWithImpl(UnknownDioErrorOptions _value,
      $Res Function(UnknownDioErrorOptions) _then)
      : super(_value, (v) => _then(v as UnknownDioErrorOptions));

  @override
  UnknownDioErrorOptions get _value => super._value as UnknownDioErrorOptions;
}

/// @nodoc
class _$UnknownDioErrorOptions
    with DiagnosticableTreeMixin
    implements UnknownDioErrorOptions {
  const _$UnknownDioErrorOptions();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DioErrorOptions.unknown()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'DioErrorOptions.unknown'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnknownDioErrorOptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult response(),
    @required TResult connection_timeout(),
    @required TResult send_timeout(),
    @required TResult receive_timeout(),
    @required TResult cancel(),
    @required TResult default_error(),
    @required TResult unknown(),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult response(),
    TResult connection_timeout(),
    TResult send_timeout(),
    TResult receive_timeout(),
    TResult cancel(),
    TResult default_error(),
    TResult unknown(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult response(ResponseDioErrorOptions value),
    @required
        TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    @required TResult send_timeout(SendTimeoutDioErrorOptions value),
    @required TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    @required TResult cancel(CancelDioErrorOptions value),
    @required TResult default_error(DefaultErrorDioErrorOptions value),
    @required TResult unknown(UnknownDioErrorOptions value),
  }) {
    assert(response != null);
    assert(connection_timeout != null);
    assert(send_timeout != null);
    assert(receive_timeout != null);
    assert(cancel != null);
    assert(default_error != null);
    assert(unknown != null);
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult response(ResponseDioErrorOptions value),
    TResult connection_timeout(ConnectionTimeoutDioErrorOptions value),
    TResult send_timeout(SendTimeoutDioErrorOptions value),
    TResult receive_timeout(ReceiveTimeoutDioErrorOptions value),
    TResult cancel(CancelDioErrorOptions value),
    TResult default_error(DefaultErrorDioErrorOptions value),
    TResult unknown(UnknownDioErrorOptions value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class UnknownDioErrorOptions implements DioErrorOptions {
  const factory UnknownDioErrorOptions() = _$UnknownDioErrorOptions;
}
